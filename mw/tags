!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	Development	//
Attribute	HTMLTemplate.hx	/^enum Attribute {$/;"	t
E	HTMLTemplate.hx	/^typedef E = $/;"	t
ExprBuilder	HTMLTemplate.hx	/^class ExprBuilder {$/;"	c
HTMLTemplate	HTMLTemplate.hx	/^class HTMLTemplate {$/;"	c
ParsedTemplateItem	HTMLTemplate.hx	/^enum ParsedTemplateItem {$/;"	t
ParserState	HTMLTemplate.hx	/^typedef ParserState = {$/;"	t
TemplateContent	HTMLTemplate.hx	/^typedef TemplateContent = Array<ParsedTemplateItem>;$/;"	t
TemplateParser	HTMLTemplate.hx	/^class TemplateParser {$/;"	c
attr_expr	HTMLTemplate.hx	/^  attr_expr(e:E); \/\/ must recturn hash or {} object$/;"	t
attr_name_expr_as_value	HTMLTemplate.hx	/^  attr_name_expr_as_value(name:String, expr:E);$/;"	t
attr_name_value	HTMLTemplate.hx	/^  attr_name_value(name:String, value:String);$/;"	t
attrsToHtml	HTMLTemplate.hx	/^  static public function attrsToHtml(a:Dynamic) {$/;"	f
autoclose	HTMLTemplate.hx	/^  static public var autoclose = ["meta","img","link","br","hr","input","area","param","col","base"];$/;"	v
break	HTMLTemplate.hx	/^             break;$/;"	t
break	HTMLTemplate.hx	/^            break;$/;"	t
break	HTMLTemplate.hx	/^          break;$/;"	t
c	HTMLTemplate.hx	/^                        c;$/;"	t
c	HTMLTemplate.hx	/^  @:macro static function c(char_str: ExprOf<String>):ExprOf<Int> {$/;"	f
code	HTMLTemplate.hx	/^  static inline function code(ps: ParserState) {$/;"	f
control_for	HTMLTemplate.hx	/^  control_for(for_:E, content: TemplateContent);$/;"	t
control_if	HTMLTemplate.hx	/^  control_if(cond:E, then_: TemplateContent, else_: TemplateContent \/* can be empty list*\/);$/;"	t
eof	HTMLTemplate.hx	/^  static inline public function eof(ps:ParserState) {$/;"	f
expect_char	HTMLTemplate.hx	/^    expect_char(":"); ps.i++;$/;"	t
expect_char	HTMLTemplate.hx	/^  @:macro static function expect_char(char:ExprOf<String>):ExprOf<Bool> {$/;"	f
expr	HTMLTemplate.hx	/^  expr(e:E, quoted: Bool); \/\/ e should return a string$/;"	t
expr	HTMLTemplate.hx	/^  public function expr(e:Expr) {$/;"	f
exprToCode	HTMLTemplate.hx	/^  static function exprToCode(char_str:Expr):Int{$/;"	f
false	HTMLTemplate.hx	/^        false;$/;"	t
filter	HTMLTemplate.hx	/^  filter(name:String, e:TemplateContent);$/;"	t
for_s	HTMLTemplate.hx	/^          for_s;$/;"	t
haml_like_str	HTMLTemplate.hx	/^  @:macro static public function haml_like_str(template:Expr): Expr {$/;"	f
ignore_spaces	HTMLTemplate.hx	/^  static inline public function ignore_spaces(ps:ParserState) {$/;"	f
is_char	HTMLTemplate.hx	/^  @:macro static function is_char(char:ExprOf<String>):ExprOf<Bool> {$/;"	f
is_string	HTMLTemplate.hx	/^  @:macro static function is_string(string:ExprOf<String>):ExprOf<Bool> {$/;"	f
items	HTMLTemplate.hx	/^  public var items:Array<Expr>;$/;"	v
makePos	HTMLTemplate.hx	/^  static public function makePos(ps: ParserState) {$/;"	f
new	HTMLTemplate.hx	/^  public function new() {$/;"	f
parse_attr_value	HTMLTemplate.hx	/^  static public function parse_attr_value(ps) {$/;"	f
parse_code	HTMLTemplate.hx	/^  static public function parse_code(ii:Int, ps:ParserState):ParsedTemplateItem {$/;"	f
parse_failure	HTMLTemplate.hx	/^        parse_failure(ps, ":for, :if or any of the known filters "+ ps.available_filters.join(",")+" prefixed by : expected");$/;"	t
parse_failure	HTMLTemplate.hx	/^  static public function parse_failure(ps:ParserState, msg:String) {$/;"	f
parse_haxe_expr	HTMLTemplate.hx	/^  static public function parse_haxe_expr(ps:ParserState):E {$/;"	f
parse_name_like	HTMLTemplate.hx	/^  static public function parse_name_like(ps:ParserState) {$/;"	f
parse_tag	HTMLTemplate.hx	/^  static public function parse_tag(ii:Int, ps:ParserState):ParsedTemplateItem {$/;"	f
parse_template	HTMLTemplate.hx	/^  public static function parse_template(pos, s:String, available_filters: Array<String>):TemplateContent {$/;"	f
parse_template_items	HTMLTemplate.hx	/^  static function parse_template_items(ii:Int, ps: ParserState, r:TemplateContent){$/;"	f
parse_text	HTMLTemplate.hx	/^  static public function parse_text(ii:Null<Int>, ps:ParserState, r:Array<ParsedTemplateItem> ) {$/;"	f
parse_text_line	HTMLTemplate.hx	/^  static public function parse_text_line(ps, r:Array<ParsedTemplateItem>, first_line:Bool) {$/;"	f
return	HTMLTemplate.hx	/^          return;$/;"	t
return	HTMLTemplate.hx	/^        return;$/;"	t
s	HTMLTemplate.hx	/^                  s;$/;"	t
s	HTMLTemplate.hx	/^  public function s(s:String) {$/;"	f
spaces	HTMLTemplate.hx	/^  static public function spaces(count:Int, ps:ParserState) {$/;"	f
tag	HTMLTemplate.hx	/^  tag(name:String, attributes:Array<Attribute>, contents:TemplateContent, add_space:Bool);$/;"	t
template_content_to_expr	HTMLTemplate.hx	/^  static public function template_content_to_expr(ptis:Array<ParsedTemplateItem>, last_no_space:Bool, e:$/;"	f
template_to_str_expr	HTMLTemplate.hx	/^  public static function template_to_str_expr(pos: {file:String, min:Int, max:Int}, s:String, last_no_space:Bool = true):Expr {$/;"	f
text	HTMLTemplate.hx	/^  text(s:String); \/\/ html$/;"	t
true	HTMLTemplate.hx	/^        true;$/;"	t
walk_haxe_expr	HTMLTemplate.hx	/^  static public function walk_haxe_expr(ps:ParserState, repeat:Bool = false) {$/;"	f
